// Code generated by builtingen ../language/reference.hlb reference.go; DO NOT EDIT.

package gen

var (
	Reference = Lookup{
		BuiltinsByType: map[string]BuiltinsLookup{
			"fs": BuiltinsLookup{
				FuncByName: map[string]*Func{
					"generate": &Func{
						Doc:    "Generates a filesystem using an external frontend.",
						Type:   "fs",
						Method: false,
						Name:   "generate",
						Params: []Field{
							{
								Doc:      "a filesystem with an executable that runs a BuildKit gateway GRPC client over stdio.",
								Variadic: false,
								Type:     "fs",
								Name:     "frontend",
							},
						},
						Options: []*Func{
							{
								Doc:    "Provide an input filesystem to the external frontend. Read the documentation\nfor the frontend to see what it will accept.",
								Type:   "option::generate",
								Method: false,
								Name:   "frontendInput",
								Params: []Field{
									{
										Doc:      "an unique key for the input.",
										Variadic: false,
										Type:     "string",
										Name:     "key",
									},
									{
										Doc:      "a filesystem as an input.",
										Variadic: false,
										Type:     "fs",
										Name:     "value",
									},
								},
							},
							{
								Doc:    "Provide a key value pair to the external frontend. Read the documentation\nfor the frontend to see what it will accept.",
								Type:   "option::generate",
								Method: false,
								Name:   "frontendOpt",
								Params: []Field{
									{
										Doc:      "an unique key for the option.",
										Variadic: false,
										Type:     "string",
										Name:     "key",
									},
									{
										Doc:      "a value for the option.",
										Variadic: false,
										Type:     "string",
										Name:     "value",
									},
								},
							},
						},
					},
					"git": &Func{
						Doc:    "A filesystem with the files from a git repository checked out from\na git reference. Note that by default, the `.git` directory is not included.",
						Type:   "fs",
						Method: false,
						Name:   "git",
						Params: []Field{
							{
								Doc:      "the fully qualified git remote.",
								Variadic: false,
								Type:     "string",
								Name:     "remote",
							},
							{
								Doc:      "the git reference to check out.",
								Variadic: false,
								Type:     "string",
								Name:     "ref",
							},
						},
						Options: []*Func{
							{
								Doc:    "Keeps the `.git` directory of the git repository.",
								Type:   "option::git",
								Method: false,
								Name:   "keepGitDir",
							},
						},
					},
					"http": &Func{
						Doc:    "A filesystem with a file retrieved from a HTTP URL.",
						Type:   "fs",
						Method: false,
						Name:   "http",
						Params: []Field{
							{
								Doc:      "a fully-qualified URL to send a HTTP GET request.",
								Variadic: false,
								Type:     "string",
								Name:     "url",
							},
						},
						Options: []*Func{
							{
								Doc:    "Verifies the checksum of the retrieved file against a digest.",
								Type:   "option::http",
								Method: false,
								Name:   "checksum",
								Params: []Field{
									{
										Doc:      "a checksum in the form of an OCI digest. https://github.com/opencontainers/image-spec/blob/master/descriptor.md#digests",
										Variadic: false,
										Type:     "string",
										Name:     "digest",
									},
								},
							},
							{
								Doc:    "Modifies the permissions of the retrieved file.",
								Type:   "option::http",
								Method: false,
								Name:   "chmod",
								Params: []Field{
									{
										Doc:      "the new permissions of the file in int.",
										Variadic: false,
										Type:     "int",
										Name:     "filemode",
									},
								},
							},
							{
								Doc:    "Writes the retrieved file with a specified name.",
								Type:   "option::http",
								Method: false,
								Name:   "filename",
								Params: []Field{
									{
										Doc:      "the name of the file.",
										Variadic: false,
										Type:     "string",
										Name:     "name",
									},
								},
							},
						},
					},
					"image": &Func{
						Doc:    "An OCI image's filesystem.",
						Type:   "fs",
						Method: false,
						Name:   "image",
						Params: []Field{
							{
								Doc:      "a docker registry reference. if not fully qualified, it will be expanded the same as the docker CLI.",
								Variadic: false,
								Type:     "string",
								Name:     "ref",
							},
						},
						Options: []*Func{
							{
								Doc:    "Resolves the OCI Image Config and inherit its environment, working directory,\nand entrypoint.",
								Type:   "option::image",
								Method: false,
								Name:   "resolve",
							},
						},
					},
					"local": &Func{
						Doc:    "A filesystem with the files synced up from a directory on the\nlocal system.",
						Type:   "fs",
						Method: false,
						Name:   "local",
						Params: []Field{
							{
								Doc:      "the local path to the directory to sync up.",
								Variadic: false,
								Type:     "string",
								Name:     "path",
							},
						},
						Options: []*Func{
							{
								Doc:    "Sync only files that do not match any of the excluded patterns.",
								Type:   "option::local",
								Method: false,
								Name:   "excludePatterns",
								Params: []Field{
									{
										Doc:      "a list of patterns for files that should not be synced.",
										Variadic: true,
										Type:     "string",
										Name:     "pattern",
									},
								},
							},
							{
								Doc:    "Sync the targets of symlinks if path is to a symlink.",
								Type:   "option::local",
								Method: false,
								Name:   "followPaths",
								Params: []Field{
									{
										Doc:      "a list of paths to files that may be symlinks.",
										Variadic: true,
										Type:     "string",
										Name:     "path",
									},
								},
							},
							{
								Doc:    "Sync only files that match any of the included patterns.",
								Type:   "option::local",
								Method: false,
								Name:   "includePatterns",
								Params: []Field{
									{
										Doc:      "a list of patterns for files that should be synced.",
										Variadic: true,
										Type:     "string",
										Name:     "pattern",
									},
								},
							},
						},
					},
					"scratch": &Func{
						Doc:    "An empty filesystem.",
						Type:   "fs",
						Method: false,
						Name:   "scratch",
					},

					"copy": &Func{
						Doc:    "Copies a file from an input filesystem into the current filesystem.",
						Type:   "fs",
						Method: true,
						Name:   "copy",
						Params: []Field{
							{
								Doc:      "the filesystem to copy from.",
								Variadic: false,
								Type:     "fs",
								Name:     "input",
							},
							{
								Doc:      "the path from the input filesystem.",
								Variadic: false,
								Type:     "string",
								Name:     "src",
							},
							{
								Doc:      "the path in the current filesystem.",
								Variadic: false,
								Type:     "string",
								Name:     "dst",
							},
						},
						Options: []*Func{
							{
								Doc:    "If the `src` path is a directory, only the contents of the directory is\ncopied to the destination.",
								Type:   "option::copy",
								Method: false,
								Name:   "contentsOnly",
							},
							{
								Doc:    "Create the parent directories of the destination if they don't already exist.",
								Type:   "option::copy",
								Method: false,
								Name:   "createDestPath",
							},
							{
								Doc:    "Follow symlinks in the input filesystem and copy the symlink targets too.",
								Type:   "option::copy",
								Method: false,
								Name:   "followSymlinks",
							},
							{
								Doc:    "If the `src` path is an archive, attempt to unpack its contents into the\ndestination.",
								Type:   "option::copy",
								Method: false,
								Name:   "unpack",
							},
						},
					},
					"dir": &Func{
						Doc:    "Sets the working directory for all subsequent calls in this filesystem block.",
						Type:   "fs",
						Method: true,
						Name:   "dir",
						Params: []Field{
							{
								Doc:      "the new working directory.",
								Variadic: false,
								Type:     "string",
								Name:     "path",
							},
						},
					},
					"env": &Func{
						Doc:    "Sets an environment key pair for all subsequent calls in this filesystem\nblock.",
						Type:   "fs",
						Method: true,
						Name:   "env",
						Params: []Field{
							{
								Doc:      "the environment key.",
								Variadic: false,
								Type:     "string",
								Name:     "key",
							},
							{
								Doc:      "the environment value.",
								Variadic: false,
								Type:     "string",
								Name:     "value",
							},
						},
					},
					"mkdir": &Func{
						Doc:    "Creates a directory in the current filesystem.",
						Type:   "fs",
						Method: true,
						Name:   "mkdir",
						Params: []Field{
							{
								Doc:      "the path of the directory.",
								Variadic: false,
								Type:     "string",
								Name:     "path",
							},
							{
								Doc:      "the permissions of the directory.",
								Variadic: false,
								Type:     "int",
								Name:     "filemode",
							},
						},
						Options: []*Func{
							{
								Doc:    "Change the owner of the directory.",
								Type:   "option::mkdir",
								Method: false,
								Name:   "chown",
								Params: []Field{
									{
										Doc:      "the user:group owner of the directory.",
										Variadic: false,
										Type:     "string",
										Name:     "owner",
									},
								},
							},
							{
								Doc:    "Create the parent directories if they don't exist already.",
								Type:   "option::mkdir",
								Method: false,
								Name:   "createParents",
							},
							{
								Doc:    "Sets the created time of the directory.",
								Type:   "option::mkdir",
								Method: false,
								Name:   "createdTime",
								Params: []Field{
									{
										Doc:      "the created time in the RFC3339 format.",
										Variadic: false,
										Type:     "string",
										Name:     "created",
									},
								},
							},
						},
					},
					"mkfile": &Func{
						Doc:    "Creates a file in the current filesystem.",
						Type:   "fs",
						Method: true,
						Name:   "mkfile",
						Params: []Field{
							{
								Doc:      "the path of the file.",
								Variadic: false,
								Type:     "string",
								Name:     "path",
							},
							{
								Doc:      "the permissions of the file.",
								Variadic: false,
								Type:     "int",
								Name:     "filemode",
							},
							{
								Doc:      "the contents of the file.",
								Variadic: false,
								Type:     "string",
								Name:     "content",
							},
						},
						Options: []*Func{
							{
								Doc:    "Change the owner of the file.",
								Type:   "option::mkfile",
								Method: false,
								Name:   "chown",
								Params: []Field{
									{
										Doc:      "the user:group owner of the file.",
										Variadic: false,
										Type:     "string",
										Name:     "owner",
									},
								},
							},
							{
								Doc:    "Sets the created time of the file.",
								Type:   "option::mkfile",
								Method: false,
								Name:   "createdTime",
								Params: []Field{
									{
										Doc:      "the created time in the RFC3339 format.",
										Variadic: false,
										Type:     "string",
										Name:     "created",
									},
								},
							},
						},
					},
					"rm": &Func{
						Doc:    "Removes a file from the current filesystem.",
						Type:   "fs",
						Method: true,
						Name:   "rm",
						Params: []Field{
							{
								Doc:      "the path of the file to remove.",
								Variadic: false,
								Type:     "string",
								Name:     "path",
							},
						},
						Options: []*Func{
							{
								Doc:    "Allows the file to not be found.",
								Type:   "option::rm",
								Method: false,
								Name:   "allowNotFound",
							},
							{
								Doc:    "Allows wildcards in the path to remove.",
								Type:   "option::rm",
								Method: false,
								Name:   "allowWildcards",
							},
						},
					},
					"run": &Func{
						Doc:    "Executes an command in the current filesystem.\nIf no arguments are given, it will execute the current args set on the\nfilesystem.\nIf exactly one arg is given, it will attempt to parse as a command with\nshell-style quoting. If it remains a single element, it is executed directly,\notherwise it is run with the current shell.\nIf more than one arg is given, it will be executed directly, without a shell.",
						Type:   "fs",
						Method: true,
						Name:   "run",
						Params: []Field{
							{
								Doc:      "a command to execute.",
								Variadic: true,
								Type:     "string",
								Name:     "arg",
							},
						},
						Options: []*Func{
							{
								Doc:    "Sets the working directory for the duration of the run command.",
								Type:   "option::run",
								Method: false,
								Name:   "dir",
								Params: []Field{
									{
										Doc:      "the new working directory.",
										Variadic: false,
										Type:     "string",
										Name:     "path",
									},
								},
							},
							{
								Doc:    "Sets an environment key pair for the duration of the run command.",
								Type:   "option::run",
								Method: false,
								Name:   "env",
								Params: []Field{
									{
										Doc:      "the environment key.",
										Variadic: false,
										Type:     "string",
										Name:     "key",
									},
									{
										Doc:      "the environment value.",
										Variadic: false,
										Type:     "string",
										Name:     "value",
									},
								},
							},
							{
								Doc:    "Adds a host entry to /etc/hosts for the duration of the run command.",
								Type:   "option::run",
								Method: false,
								Name:   "host",
								Params: []Field{
									{
										Doc:      "the host name of the entry, may include spaces to delimit multiple host names.",
										Variadic: false,
										Type:     "string",
										Name:     "hostname",
									},
									{
										Doc:      "the IP of the entry.",
										Variadic: false,
										Type:     "string",
										Name:     "address",
									},
								},
							},
							{
								Doc:    "Attaches an additional filesystem for the duration of the run command.",
								Type:   "option::run",
								Method: false,
								Name:   "mount",
								Params: []Field{
									{
										Doc:      "the additional filesystem to mount. the input's root filesystem becomes available from the mountPoint directory.",
										Variadic: false,
										Type:     "fs",
										Name:     "input",
									},
									{
										Doc:      "the directory where the mount is attached.",
										Variadic: false,
										Type:     "string",
										Name:     "mountPoint",
									},
								},
								Options: []*Func{
									{
										Doc:    "Sets the mount to be attached as a read-only filesystem.",
										Type:   "option::mount",
										Method: false,
										Name:   "readonly",
									},
									{
										Doc:    "Sets the mount to be attached as a tmpfs filesystem.",
										Type:   "option::mount",
										Method: false,
										Name:   "tmpfs",
									},
									{
										Doc:    "Mount a path from the input filesystem. By default, the root of the input\nfilesystem is mounted.",
										Type:   "option::mount",
										Method: false,
										Name:   "sourcePath",
										Params: []Field{
											{
												Doc:      "the path in the input filesystem.",
												Variadic: false,
												Type:     "string",
												Name:     "path",
											},
										},
									},
									{
										Doc:    "Cache a snapshot of the mount after the run command has executed. A cacheid\nmust be provided to uniquely identify the cache mount.\nCompilers and package managers commonly have an option to specify cache\ndirectories. Depending on their implementation, it may be safe to share the\ncache with concurrent processes. This is adjusted via the `sharingmode`\nargument.\nThe cache is modified every time the parent run command is executed. A cache\ncould also be managed by not using the `cache` option. Instead, the mount can\nbe aliased, and then pushed as an image, so that there it can be a stable\nsnapshot, or updated externally.",
										Type:   "option::mount",
										Method: false,
										Name:   "cache",
										Params: []Field{
											{
												Doc:      "the unique ID to identify the cache.",
												Variadic: false,
												Type:     "string",
												Name:     "cacheid",
											},
											{
												Doc:      "the sharing mode of the cache, must be one of the following: - shared: can be used concurrently by multiple writers. - private: creates a new mount if there are multiple writers. - locked: pauses additional writers until the first one releases the mount.",
												Variadic: false,
												Type:     "string",
												Name:     "sharingmode",
											},
										},
									},
								},
							},
							{
								Doc:    "Sets the networking mode for the duration of the run command. By default, the\nvalue is `unset` (using BuildKit's CNI provider, otherwise its host\nnamespace).",
								Type:   "option::run",
								Method: false,
								Name:   "network",
								Params: []Field{
									{
										Doc:      "the network mode of the container, must be one of the following: - unset: use the default network provider. - host: use the host's network namespace. - none: disable networking.",
										Variadic: false,
										Type:     "string",
										Name:     "networkmode",
									},
								},
							},
							{
								Doc:    "Sets the rootfs as read-only for the duration of the run command.",
								Type:   "option::run",
								Method: false,
								Name:   "readonlyRootfs",
							},
							{
								Doc:    "Mounts a secure file for the duration of the run command. Secrets are\nattached via a tmpfs mount, so all the data stays in volatile memory.",
								Type:   "option::run",
								Method: false,
								Name:   "secret",
								Params: []Field{
									{
										Doc:      "the filepath for a secure file or directory.",
										Variadic: false,
										Type:     "string",
										Name:     "localPath",
									},
									{
										Doc:      "the directory where the secret is attached.",
										Variadic: false,
										Type:     "string",
										Name:     "mountPoint",
									},
								},
								Options: []*Func{
									{
										Doc:    "Sets the user ID for the secure file. By default, the UID is 0.",
										Type:   "option::secret",
										Method: false,
										Name:   "uid",
										Params: []Field{
											{
												Doc:      "the user id.",
												Variadic: false,
												Type:     "int",
												Name:     "id",
											},
										},
									},
									{
										Doc:    "Sets the group ID for the secure file. By default, the GID is 0.",
										Type:   "option::secret",
										Method: false,
										Name:   "gid",
										Params: []Field{
											{
												Doc:      "the group id.",
												Variadic: false,
												Type:     "int",
												Name:     "id",
											},
										},
									},
									{
										Doc:    "Sets the permissions for the secure file. By default, the file mode is 0o600.",
										Type:   "option::secret",
										Method: false,
										Name:   "mode",
										Params: []Field{
											{
												Doc:      "the new permissions of the secure file in int.",
												Variadic: false,
												Type:     "int",
												Name:     "filemode",
											},
										},
									},
								},
							},
							{
								Doc:    "Sets the security mode for the duration of the run command. By default, the\nvalue is `sandbox`.",
								Type:   "option::run",
								Method: false,
								Name:   "security",
								Params: []Field{
									{
										Doc:      "the security mode of the container, must be one of the following: - sandbox: use the default containerd seccomp profile. - insecure: enables all capabilities.",
										Variadic: false,
										Type:     "string",
										Name:     "securitymode",
									},
								},
							},
							{
								Doc:    "Mounts a SSH socket for the duration of the run command. By default, it will\ntry to use the SSH socket found from $SSH_AUTH_SOCK. Otherwise, an option\n`localPath` can be provided to specify a filepath to a SSH auth socket or\n*.pem file.",
								Type:   "option::run",
								Method: false,
								Name:   "ssh",

								Options: []*Func{
									{
										Doc:    "Sets the target directory to mount the SSH agent socket. By default, it is\nmounted to `/run/buildkit/ssh_agent.${N}`, where N is the index of the\nsocket. If $SSH_AUTH_SOCK is not set, it will set SSH_AUTH_SOCK to the\nmountPoint.",
										Type:   "option::ssh",
										Method: false,
										Name:   "target",
										Params: []Field{
											{
												Doc:      "the directory where the SSH agent socket is attached.",
												Variadic: false,
												Type:     "string",
												Name:     "mountPoint",
											},
										},
									},
									{
										Doc:    "Sets the path to a local SSH agent socket or PEM key, with support for\npassphrases. By default, the SSH agent defined by $SSH_AUTH_SOCK will be\nmounted into the container.",
										Type:   "option::ssh",
										Method: false,
										Name:   "localPath",
										Params: []Field{
											{
												Doc:      "the path to a local SSH agent socket or PEM key.",
												Variadic: false,
												Type:     "string",
												Name:     "path",
											},
										},
									},
									{
										Doc:    "Sets the user ID for the SSH agent socket. By default, the UID is 0.",
										Type:   "option::ssh",
										Method: false,
										Name:   "uid",
										Params: []Field{
											{
												Doc:      "the user ID.",
												Variadic: false,
												Type:     "int",
												Name:     "id",
											},
										},
									},
									{
										Doc:    "Sets the group ID for the SSH agent socket. By default, the GID is 0.",
										Type:   "option::ssh",
										Method: false,
										Name:   "gid",
										Params: []Field{
											{
												Doc:      "the group ID.",
												Variadic: false,
												Type:     "int",
												Name:     "id",
											},
										},
									},
									{
										Doc:    "Sets the permissions for the SSH agent socket. By default, the file mode is\n0o600.",
										Type:   "option::ssh",
										Method: false,
										Name:   "mode",
										Params: []Field{
											{
												Doc:      "the new permissions of the SSH agent socket in int.",
												Variadic: false,
												Type:     "int",
												Name:     "filemode",
											},
										},
									},
								},
							},
							{
								Doc:    "Sets the current user for the duration of the run command.",
								Type:   "option::run",
								Method: false,
								Name:   "user",
								Params: []Field{
									{
										Doc:      "the name of the user.",
										Variadic: false,
										Type:     "string",
										Name:     "name",
									},
								},
							},
						},
					},
					"shell": &Func{
						Doc:    "Sets the current shell command to use when executing subsequent `run`\nmethods. By default, this is [\"sh\", \"-c\"].",
						Type:   "fs",
						Method: true,
						Name:   "shell",
						Params: []Field{
							{
								Doc:      "the list of args used to prefix `run` statements.",
								Variadic: true,
								Type:     "string",
								Name:     "arg",
							},
						},
					},
					"user": &Func{
						Doc:    "Sets the current user for all subsequent calls in this filesystem block.",
						Type:   "fs",
						Method: true,
						Name:   "user",
						Params: []Field{
							{
								Doc:      "the name of the user.",
								Variadic: false,
								Type:     "string",
								Name:     "name",
							},
						},
					},
				},
			},
		},
	}
)
